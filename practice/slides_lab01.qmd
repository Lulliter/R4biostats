---
title: "Lab 1: Intro to R and data analysis"
subtitle: "<span style='font-size:2em;'> .... more details </span>"
author: "<a href='https://r4biostats.com/me.html' style='color:#72aed8;font-weight:600;'>M. Chiara Mimmi, Ph.D.</a>&ensp;|&ensp;Universit√† degli Studi di Pavia"
date: 2024-07-25
date-format: long
code-link: true
format:
  revealjs:
    smaller: true
    scrollable: true
    theme: ../theme/slidesMine.scss # QUARTO LOOKS IN SAME FOLDER 
#    logo: imgs_slides/mitgest_logo.png
    footer: '[R 4 Biostatistics](https://r4biostats.com/) | MITGEST::training(2024)'
#    footer: <https://lulliter.github.io/R4biostats/lectures.html>
## ------------- x salvare come PDF 
    standalone: false
    ## -------Produce a standalone HTML file with no external dependencies,
    embed-resources: true
    transition: fade
    background-transition: fade
    highlight-style: ayu-mirage
    slide-number: true
    fig-cap-location: top
    # fig-format: svg
    pdf-separate-fragments: false
    # fig-align: center
execute:
  # Quarto pre code blocks do not echo their source code by default
  echo: true
  include: true
  freeze: auto
---

# Lecture 1: topics illustrated in class

-   Introduction to R and R-studio
    -   Why R?
    -   Principles of reproducible analysis with R + RStudio
-   R objects, functions, packages
-   Understanding different types of variables
    -   Principles of "tidy data"
-   Descriptive statistics
    -   Measures of central tendency, measures of variability (or spread), and frequency distribution
-   Visual data exploration
    -   {`ggplot2`}
-   Foundations of inference

# INTRO TO R AND RSTUDIO

## R version
If you have previously installed R on your machine, you can check which version you are running by executing this command in `R`:

```{r}
# check your R version
R.Version()

# or just
#R.version.string
```

## Install `r fontawesome::fa("r-project", fill = "#5F85A7")`

<!-- `r fontawesome::fa("fab fa-windows", fill = "steelblue")` -->

<!-- `r fontawesome::fa("fab fa-linux", fill = "steelblue")` -->

<!-- `r fontawesome::fa("fab fa-apple", fill = "steelblue")` -->

**R** is available for free for Windows [{{< fa brands windows >}}]{style="color:#d8717b"}, GNU/Linux [{{< fa brands linux >}}]{style="color:#d8717b"}, and macOS [{{< fa brands apple >}}]{style="color:#d8717b"}.

-   To install **R**, you can go to this [**https://cloud.r-project.org/**](https://cloud.r-project.org/). The latest available release is **R 4.3.3 "Angel Food Cake" released on 2024-02/29**, but any (fairly recent) version will do.

## Install RStudio IDE

**RStudio Desktop** is an Integrated Development Editor (IDE), basically a graphical interface wrapping and interfacing R (which needs to be installed first).

Besides RStudio, R (which is a command line driven program) can be executed:

+ via its native interface (**R GUI**)
+ from many other code editors, like **VS Code**, **Sublime Text**, **Jupyter Notebook** 

-   To install **RStudio** you can go to this [**https://posit.co/download/rstudio-desktop/**](https://posit.co/download/rstudio-desktop/). The free-version contains everything you need.

## Use RStudio IDE

![RStudio Pane Layout [Source: Posit's RStudio User Guide](https://docs.posit.co/ide/user/ide/guide/ui/ui-panes.html)](../images/rstudio-panes-labeled.jpeg)

## Creating an R Project \[in Rstudio\]
An **R Project** will keep all the files associated with a project (including invisible ones!) organized together -- input data, R scripts, analytical results, figures. Besides being common practice, this has the advantage of implicitly setting the "working directory", which is incredibly important when you need to load or output files, specifying their file path.

In @fig-Rproj_cre you can see how easy it is just following RStudio prompts:

-   Create a new directory for each project
-   Select parent folder

## Creating an R Project \[in Rstudio\] (cont.)

![Creating an R project](../images/RProj_new_proj.png){#fig-Rproj_cre}

::: aside
Notice that, now, in the `Files` tab you see file with the extension `.Rproj` which is telling R that all folder's files belong together.
::: 

## Install R packages from CRAN (stable version)
An **R  package* ** is a shareable bundle of functions. Besides the basic built-in functions already contained in the program (i.e. the `base` package), many useful R functions come in free libraries of code (or *packages*) written by R's users. You can find them in different repositories:

To install a package use `utils` function `install.packages("package_name)`

```{r}
#| eval: false

# Installing (ONLY the 1st time)
utils::install.packages('here')

# OR (same)
install.packages('here')

```

::: {.aside}
Here you are actually using a ***function*** (`install.packages`) of a pre-installed ***package*** (`utils`) using the syntax `packagename::function_name`. This prevents any ambiguity in case of duplicate function name... also helps you see what you are using.
:::

## Install R packages from GitHub (testing version)

With the package `devtools` and its function `install_github` to install the developer's version of a package. Let's try it with a little package `paint` (which colors the structure of dataset when printing).

::: panel-tabset
### Code

```{r}
#| eval: false

# Installing devtools (ONLY the 1st time)
utils::install.packages('devtools')

# Installing paint from GitHub 
library(devtools)
devtools::install_github("MilesMcBain/paint")

# test paint out
library(paint)
```


::: {.aside}
After `devtools::install_github("MilesMcBain/paint")`, R asks me if I want to update related packages... respond in the console choosing the preferred answer.
:::

### Output {str} function
```{r}
# ... instead of plain old 
print(str(mtcars))
```


### Output {paint} function
```{r}
#| eval: false

# it will show me the structure of a data.frame like this... 
paint::paint(mtcars)
``` 

![](../images/paint.png)
:::

## Install R packages RStudio pane

You can also install and update packages using the "Packages" tab on the lower right pane of RStudio.

![Screenshot Install/Update pckgs from RStudio](../images/RStudio_install_pckg_2way.png)

## Use R Packages

+ We will be using {base} & {utils} (pre-installed and pre-loaded) 
+ We will also use the packages below (specifying `package::function` for clarity).

```{r}
# Load them for this R session
library(here)      # tools find your project's files, based on working directory
library(janitor)   # tools for examining and cleaning data
library(skimr)     # tools for summary statistics 
library(dplyr)     # {tidyverse} tools for manipulating and summarising tidy data 
library(ggplot2)   # {tidyverse} tools for plotting
library(forcats)   # {tidyverse} tool for handling factors
library(ggridges)  # alternative to plot density functions 
library(fs)        # file/directory interactions
```

## Help on R package/function

To inquire about a package and/or its functions, you can again write in your console `?package_name` or `??package_name` and RStudio will open up the `Help` page in the lower right pane.

```{r}
# Opening Help page on package/function
?here

??here
```

## File paths logistics

It is never good practice to "hard code" the file's *absolute path*: most likely it will break your code as soon as you (or someone else) need to run it on a different computer, let alone within a different OS.

So if your code to read & load a file is written like this:

```{r}
#| eval: false

# [NOT REPRODUCIBLE] hard coding your file path  -----------------------

# File path on Mac:
dataset <- readr::read_csv(
  "/Users/testuser/R4biostats/input_data/dataset.csv")
# Same file path on Windows:
dataset <- readr::read_csv(
  "C:\Users\testuser\R4biostats\input_data\dataset.csv")
```

...it won't work on someone else's computer since they don't have that same file structure!


## (Reproducible) file paths with `here` \[in Rstudio\]
The [`here`](https://here.r-lib.org/) package lets you reference file paths in a *reproducible* manner (anchored on the R Project's folder as the *root*). 

<!-- 1. It let's you use **relative paths**, i.e. specify the file path relative to the project folder containing `project_name.Rproj`.  -->
<!-- 2. **No more "/" v. "\\"** issue (where Windows and Linus/Mac OSs differ) 3. Add sub folder levels separated by **","** -->

Where is my Working Directory?

```{r}
#| eval: false
here::here()
```

You should get **"/Users/dir/sub_dir/proj_name"**

Create a Sub-Directory with `fs` package (for saving input data and output data)

```{r}
#| eval: false

# with `here` I simply add subfolder names relative to my wd 
fs::dir_create(here("practice", "test","data_input"))
# ...and a subfolder to put output files at the end
fs::dir_create(here("practice", "test","data_output"))

## --- [if I need to remove it (I have them already)]
fs::dir_delete(here("practice", "test"))
```

# R OBJECTS, FUNCTIONS, PACKAGES

## Importing data into R workspace

We are using real data provided by Thabtah,Fadi. (2017). Autism Screening Adult. UCI Machine Learning Repository. [https://doi.org/10.24432/C5F019](https://doi.org/10.24432/C5F019)

We use `utils::read.csv` to load a csv file

```{r}
?read.csv # to learn about function and arguments 
```

## Option 1: from a url

+ `head` extract the first 6 rows 

```{r}
#| eval: false
autism_data_url <- read.csv(
  file = "https://raw.githubusercontent.com/Sydney-Informatics-Hub/lessonbmc/gh-pages/_episodes_rmd/data/autism_data.csv", 
  header = TRUE, # 1st line is the name of the variables
  sep = ",", # which is the field separator character.
  na.strings = c("?") # specific values R should interpret as NA
)
```

## Option 2: from my folder (upon downloading)

```{r}
# Check my working directory location
# here::here()

# Use `here` in specifying all the subfolders AFTER the working directory 
autism_data_file <- read.csv(
  file = here("practice", "data_input", "01_datasets", "autism_data.csv"), 
  header = TRUE, # 1st line is the name of the variables
  sep = ",", # which is the field separator character.
  na.strings = c("?"),# specific values R should interpret as NA
  row.names = NULL) 
```

# DATA OBSERVATION & MANIPULATION

## Viewing the dataset

```{r}
#| eval: false
View(autism_data_file)  # (or click on it in Enviroment tab)
```


```{r}
# What data type is this data?
class(autism_data_file)

# What variables are included in this dataset?
base::colnames(autism_data_file)
```

## Manipulate / clean the dataframe

I want a more consistent naming (no ".", only "\_"), so I use a very handy function `clean_names` from the {janitor} package

```{r}
autism_data <- janitor::clean_names(autism_data_file, 
                                     case = "none") 
# check change
colnames(autism_data)
dim(autism_data)
```

-   The option `case = "none"` leaves the case as is, but only uses "\_" separator (you can also use it with no arguments )

## Isolate a variable (column)

```{r}
# With the `$` sign I extract a variable (column name)
autism_data$id
autism_data$A1_Score
```

## Add a new column

I prefer to rename the dataframe when I make changes

```{r}
# rename dataframe 
autism_pids <- autism_data
# create a new column 
autism_pids$pids <- paste("PatientID_" , autism_data$id, sep = "")
base::colnames(autism_pids)

# check change in df structure
dim(autism_data)
dim(autism_pids)
```

## (optional) Clean up my workspace^[Warning: you will not have these objects in your workspace anymore]

```{r}
# what do I have in the environment? 
ls() 
# remove all EXCEPT for "autism_pids" 
rm("autism_data", "autism_data_file", "autism_data_url" ) 
```

. . .

<br>

# Different ways to select rows &/or columns

## Option 1 using the `$` sign from `base`

```{r}
# With the `$` sign I extract a variable (column name)
head(autism_pids$id) 
head(autism_pids$pids)
head(autism_pids$A1_Score)
head(autism_pids$ethnicity)
```

## Option 2 using indexing `[ , #col]` from `base`

```{r}
# Indexing to pick `[ , #col]`  
head(autism_pids[ ,1] )# empty rows means all 
head(autism_pids[ ,23])
head(autism_pids[ ,2])
head(autism_pids[ ,14])
```

## Option 2 using indexing `[#row, ]` from `base`"
```{r}
# Indexing to pick `[#row, ]`  
head(autism_pids[1 , ] ) # empty cols means all 
head(autism_pids[50,])
head(autism_pids[25:26 ,])
```

## Option 2 using indexing `[#row, #col]`  from `base`"
```{r}
# Indexing to pick `[#row, #col]`  
autism_pids[1:3,1]
autism_pids[1:3,23]
autism_pids[1:3,2]
autism_pids[1:3,14]
```

# What are the data types of the variables?


## Option 1 using `base` functions 

```{r}
# What are the data types of the variables? ---------------------------------
str(autism_pids) # integer and character
```

## Option 1 using `base` functions (cont.)
```{r}
# What values can the variables take? ---------------------------------
summary(autism_pids$pids)
length(unique(autism_pids$pids)) # N unique values
sum(is.na(autism_pids$pids)) # N missing values

summary(autism_pids$ethnicity)
length(unique(autism_pids$ethnicity)) # N unique values
sum(is.na(autism_pids$ethnicity)) # N missing values
```

## Option 2 using {skimr} function `skim`

```{r}
#| output-location: fragment

autism_pids %>% 
  skimr::skim(pids) %>%
  dplyr::select(#skim_variable, 
                skim_type, 
                complete_rate,
                n_missing, 
                character.n_unique)
```

## Option 2 using {skimr} function `skim` (cont.)
```{r}
#| output-location: fragment

autism_pids %>% 
  skimr::skim(ethnicity) %>%
  dplyr::select(#skim_variable, 
                skim_type, 
                complete_rate,
                n_missing, 
                character.n_unique)

```

## Option 2 using {skimr} function `skim` (cont.)
```{r}
#| eval: false
#| output-location: fragment

# I can use it for the WHOLE dataframe!
autism_pids %>% 
  skimr::skim()
```
 

# Recoding some variables

## from char to factor

::: panel-tabset
### from char to factor using `base`

```{r}
#### char 2 factor -------------------------------------------------------------
# Say I want to treat some variables as factors
autism_pids$gender <- as.factor(autism_pids$gender)
autism_pids$ethnicity <- as.factor(autism_pids$ethnicity)
autism_pids$contry_of_res <- as.factor(autism_pids$contry_of_res)
autism_pids$relation <- as.factor(autism_pids$relation)

 
# check 
class(autism_pids$gender)
class(autism_pids$ethnicity)
class(autism_pids$contry_of_res)
class(autism_pids$relation)
# now I have Variable type: factor
```

### from char to factor (n cols) using `base`

```{r}
autism_pids_temp <- autism_pids # copy df for test 

to_factor <- c("gender", "ethnicity", "contry_of_res", "relation") # vector of col names 
autism_pids_temp[ ,to_factor] <-  lapply(X =  autism_pids[ ,to_factor], FUN = as.factor)

# check 
class(autism_pids_temp$gender)
class(autism_pids_temp$ethnicity)
class(autism_pids_temp$contry_of_res)
class(autism_pids_temp$relation)
# now I have Variable type: factor
```
:::

## Inspect factors levels (3 different ways)

-   using {base} `levels` functions
```{r}
levels(autism_pids$ethnicity)
```

-   using {base} `table` functions
```{r}
table(autism_pids$ethnicity,useNA = "ifany")
```

## Inspect factors levels -- 3 different ways (cont.)

-   using {janitor} function `tabyl`, which uses the "pipe" operator `%>%` which takes the output of a function as input of the next one
```{r}
janitor::tabyl(autism_pids$ethnicity) %>% 
  adorn_totals() %>% 
  adorn_pct_formatting()
```

## Inspect factors levels -- 3 different ways (cont.)

- check if the 95 missing obs are the same missing for ethnicity and relation
```{r}
which(is.na(autism_pids$ethnicity)) # indices of TRUE elements in vector
which(is.na(autism_pids$relation))  # indices of TRUE elements in vector
```

...indeed they are!

## from char to logical

```{r}
# observe a subset of some columns 
autism_subset <- autism_pids [1:5, c("gender","jaundice", "autism", "age_desc", "Class_ASD","pids")]
# View(autism_subset)

# recode "age_desc" as LOGICAL new var "age_desc_log"
autism_pids$age_desc_log <- ifelse(autism_pids$age_desc == "18 and more", TRUE, FALSE )
class(autism_pids$age_desc)
class(autism_pids$age_desc_log)
```

## from char to dummy [0,1]

I also may need my binary variables expressed as 01 (e.g. to incorporate nominal variables into regression analysis)

```{r}
autism_pids$autism_dummy <- ifelse(autism_pids$autism == 'yes', 1, 0)
class(autism_pids$autism)
class(autism_pids$autism_dummy)
```

# Subsetting the data for further investigation
Recall how to view the names of columns / variables

```{r}
colnames(autism_pids)
```

## using {utils} `head` or `tail`

```{r}
#| eval: false
head(autism_pids)   #return fist 6 obs
tail(autism_pids)   #return last 6 obs
```

## using {utils} `head` or `tail` (cont.)

```{r}
head(autism_pids, n = 2) #return fist 2 obs
tail(autism_pids, n = 2) #return last 2 obs
```

## Investigating a subset of observations

E.g. I learned that some patients have missing `age`... how many are they?

```{r}
# run...
sum(is.na(autism_pids$age)) 
# or 
skimr::n_missing(autism_pids$age)
```

Next, I want to ID those patients with missing `age`

## New df (only the patients with missing `age`) as SUBSET of the given df

I want to extract only the obs (*rows*) of interest with a few useful vars (*cols*)

::: panel-tabset
### Subset using `[]` from `base` 

```{r}
missing_age_subset <- autism_pids[is.na(autism_pids$age), c("pids", "age", "autism_dummy") ]
missing_age_subset

```

### Subset using `which` from `base` 

```{r}
missing_age_subset3 <- autism_pids[which(is.na(autism_pids$age)), c("pids", "age", "autism_dummy")] 
missing_age_subset3
```
:::

## Subset using `subset` from `base` 

```{r}
# arguments allow me to specify rows and cols 
missing_age_subset2 <- subset(x = autism_pids, 
                              subset = is.na(autism_pids$age), # 1 logical condition
                              select = c("pids", "age", "autism_dummy") # which cols
                              ) 
missing_age_subset2

# Creates a SUBSET based on MORE conditions (`age` and `ethnicity`)
subset_2cond <- subset(x = autism_pids, 
                       # 2 logical conditions      
                       subset = age < 50 & contry_of_res == "Brazil", 
                       # pick a few cols 
                       select = c("pids", "age", "contry_of_res",
                                  "autism_dummy")
) 

subset_2cond
```


## Subset using {dplyr} `filter` and `select`

Switching to the package `dplyr` and embracing the "pipe" (`%>%`) operator logic, in which the filtering (rows) and selecting (columns) is done in sequence

```{r}
## here the filtering (rows) and selecting (columns) is done in sequence
twocond_dplyr_subset <- autism_pids %>% 
  dplyr::filter(age < 50 & contry_of_res == "Brazil") %>%  # which rows
  dplyr::select (pids, age, contry_of_res, autism_dummy)   # which cols

twocond_dplyr_subset
```


# Dealing with missing data

## Input values where missing

‚ö†Ô∏é WARNING ‚ö†Ô∏é This is a very delicate step, because any data that is modified or imputed beyond the original collection can affect the result of subsequent analysis and statistical modeling.

Furthermore, it will be necessary to document and justify whichever approach is used to deal with missing data.

```{r}
# 1/2 create a new variable 
autism_pids$age_inputed <- autism_pids$age
# 2/2 replace value (presumably taken from other source) of `aged_inputed` 
  # CONDITIONAL on `pids`
autism_pids$age_inputed[autism_pids$pids == "PatientID_63"] <-  65
autism_pids$age_inputed[autism_pids$pids == "PatientID_92"] <-  75

# check
skimr::n_missing(autism_pids$age) 
skimr::n_missing(autism_pids$age_inputed)  
```

 <!-- [check out !!!](https://biostats-r.github.io/biostats/workingInR/050_missing_values.html) -->

# DESCRIPTIVE STATISTICS

## Summarizing all variables

::: columns
::: {.column width="50%"}
### {base} `summary`
```{r}
#| eval: false
summary(autism_pids)
```
:::

::: {.column width="50%"}
### {skimr} `skim`
```{r}
#| eval: false
skimr::skim(autism_pids)
```
:::
:::

## Notice the different treatment according to the variable type

The function's results depend on the class of the object

-   integer (A1_Score)

```{r}
summary(autism_pids$A1_Score)     # min, max quartiles, mean, median

```

-   factor (ethnicity)

```{r}
summary(autism_pids$ethnicity)    # counts of levels' frequency (included NA!)

```

## Notice the different treatment according to the variable type

-   logical (age_desc_log)

```{r}
summary(autism_pids$age_desc_log) # counts of TRUE 
```


## Frequency tables

-   Frequency distributions can be used for nominal, ordinal, or interval/ration variables

```{r}
table(autism_pids$gender)
table(autism_pids$age) # automatically drops missing...
table(autism_pids$age, useNA = "ifany") #...unless specified

```

## Cross tabulation

-   Cross tabulation

```{r}
table(autism_pids$gender, autism_pids$age_inputed)
table(autism_pids$ethnicity, autism_pids$autism_dummy)

```

## Grouping and summarizing with {base}

E.g. I want to know the average age of men and women

Here are 3 ways using `base R

::: panel-tabset
### using `by`

```{r}
# by(data$column, data$grouping_column, mean)
by(data = autism_pids$age_inputed, INDICES = autism_pids$gender, FUN = mean)
```

### using `tapply`

```{r}
# i.e. apply a function to subsets of a vector or array, split by one or more factors.
tapply(X = autism_pids$age_inputed, INDEX = autism_pids$gender, FUN = mean)
```

### using `split` + `sapply`

```{r}
# sapply(split(data$column, data$grouping_column), mean)
sapply(X = split(autism_pids$age_inputed, autism_pids$gender),FUN = mean) # returns a vector

```
:::

## Grouping and summarizing with {dplyr}

<!-- -   {dplyr} is a key package in the {tidyverse} collection -->
<!-- -   it uses the "pipe" `%>%` and doesn't require to specify the `dataframe$col_name` but simply `col_name` -->

```{r}
autism_pids %>% 
  dplyr::group_by(gender) %>% 
  dplyr::summarise(mean(age_inputed))  # returns a dataframe!

```

I could add more statistics to the grouped summary...

```{r}
autism_pids %>% 
  dplyr::group_by(gender) %>% 
  dplyr::summarise(mean_age = mean(age_inputed),  
                   N_obs = n(), 
                   N_with_autism = sum(autism_dummy == 1)
  ) 
```

# Measures of central tendency

## Mean and median

Recall that

**MEAN** 

Sample $\mu=\frac{\sum_{i=1}^n x_{i}}n$ & Population $\bar{x}=\frac{\sum_{i=1}^n x_{i}}n$

**MEDIAN** 

For uneven $n$: $\frac{x_{(n+1)}}2$ For even $n$: $\frac{x_{(n/2)} + x_{(n/2+1)}}2$

## Mean/Median using `base`

+ Important to specify the argument `na.rm = TRUE` or the function won't work
```{r}
## Let's use `age` and `age_inputed` to see what inputed missing values did 
mean(autism_pids$age)
median(autism_pids$age)


mean(autism_pids$age, na.rm = TRUE)
median(autism_pids$age, na.rm = TRUE)

mean(autism_pids$age_inputed)
median(autism_pids$age_inputed)
```

## Create custom function to calculate statistical mode

R doesn't have it so we need a custom function for the "mode"

::: panel-tabset
### Create custom function

```{r}
f_calc_mode  <- function(x) { 
  # `unique` returns a vector of unique values 
  uni_x <- unique(x)  
  # `match` returns the index positions of 1st vector against 2nd vector
  match_x <- match(x, uni_x)
  # `tabulate` count the occurrences of integer values in a vector.
  tab_x  <-  tabulate(match_x) 
  # returns element of uni_x that corresponds to max occurrences
  uni_x[tab_x == max(tab_x)]
}
```

### Call custom function

```{r}
f_calc_mode(autism_pids$age)
f_calc_mode(autism_pids$age_inputed)
```
:::

# Measures of variability (or spread)

## Variance and Standard deviation

Recall that

**Variance** Sample $s^2 =\frac{\sum{(x_i-\bar{x})^2}}{n-1}$ & Population $\sigma^2 = \frac{\displaystyle\sum_{i=1}^{n}(x_i - \mu)^2} {n}$

**Standard deviation** Sample $s = \sqrt\frac{\sum{(x_i-\bar{x})^2}}{n-1}$ & Population $\sigma = \sqrt\frac{\displaystyle\sum_{i=1}^{n}(x_i - \mu)^2} {n}$


```{r}

var(autism_pids$age)
var(autism_pids$age_inputed)

sd(autism_pids$age)
sd(autism_pids$age_inputed)
```

# VISUAL DATA EXPLORATION

## Plotting with ggplot2

`ggplot2` provides a set of tools to map data to visual elements on a plot, to specify the kind of plot you want, and then subsequently to control the fine details of how it will be displayed. It basically allows to build a plot layer by layer (@fig-ggplot_lay).

-   **data** -\> specify what our dataset is
-   **aesthetic mappings** (or just *aesthetics*) -\> specify which dataset's variables will turn into the plot elements (e.g. $x$ and $y$ values, or categorical variable into colors, points, and shapes).
-   **geom** -\> the overall type of plot, e.g. `geom_point()` makes scatterplots, `geom_bar()` makes barplots, `geom_boxplot()` makes boxplots.

Additional (optional) pieces:

-   information about the **scales**,
-   the labels of **legends** and axes
-   other **guides** that help people to read the plot,

## Plotting with ggplot2 (cont.)
a layered approach!

![ggplot2 layers [Source: Andrew Heiss' talk](https://talks.andrewheiss.com/2021-seacen/02-ggplot2.html)](../images/ggplot-layers@4x.png){#fig-ggplot_lay}

## Save some colors (for cutomizing plots)

```{r}
two_col_palette <-  c("#9b2339", "#005ca1")
other_cols <- c("#E7B800","#239b85", "#85239b", "#9b8523","#23399b",
                "#d8e600", "#0084e6", "#399B23", "#e60066",
                "#00d8e6", "#e68000")
```

# Distribution of continuous var

## Histograms

Histograms (and density plots) are often used to show the distribution of a continuous variable.

```{r}
#| output-location: slide

ggplot(data = autism_pids, mapping = aes(x=age_inputed)) + 
  geom_histogram() + 
  theme_bw()
```


## ... or (piped data)

```{r}
#| output-location: slide

# notice the  `%>%`  before using ggplot2...
autism_pids %>% 
  # then `+` when using ggplot2
  ggplot(aes(x = age_inputed )) + 
  geom_histogram() + 
  theme_bw()
```

## ... bin width

Histograms split the data into ranges (bins) and show the number of observations in each. Hence, it's important to pick widths that represents the data well.

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes(x = age_inputed )) + 
  # specify to avoid warning if we fail to specify the number of bins 
  geom_histogram(bins=40) + 
  theme_bw()
```

## ... mean vertical line

```{r}
#| output-location: slide


autism_pids %>% 
  ggplot(aes(x = age_inputed )) + 
  # specify to avoid warning if we fail to specify the number of bins 
  geom_histogram(bins=40) + 
  # add mean vertical line
  geom_vline(xintercept = mean(autism_pids$age_inputed),
             na.rm = FALSE,
             lwd=1,
             linetype=2,
             color="#9b2339") +
  # add small annotations (such as text labels) 
  annotate("text",                        
           # coordinates for positioning aesthetics on the graph
           x = mean(autism_pids$age_inputed) * 1.4,
           y = mean(autism_pids$age_inputed) * 1.7,
           label = paste("Mean =", round(mean(autism_pids$age_inputed), digits = 2)),
           col = "#9b2339",
           size = 4)+
theme_bw() 

```

## Density plot

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes( x=age_inputed)) +
  geom_density()+
  theme_bw() 
```

## Density plot (cont.)

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes( x=age_inputed)) +
  geom_density(fill="#85239b", color="#e9ecef", alpha=0.5)+
  theme_bw() 
```

## ... increase \# of x-axis ticks

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes( x=age_inputed)) +
  geom_density(fill="#85239b", color="#e9ecef", alpha=0.5)+
  theme_bw() + 
  # increase number of x axis ticks 
  scale_x_continuous(breaks = seq(10, 100,5 ), limits = c(16, 86))
```

<!-- #theme(axis.text.x = element_text(angle = 90, size=8, vjust = 0.5, hjust=1)) -->

# Distribution of continuous var split by categorical var

## Histograms with `fill = category`

```{r}
#| output-location: slide

# specifying `fill` = gender
autism_pids %>% 
  ggplot(mapping = aes(x = age_inputed, fill = gender )) + 
  geom_histogram(bins=40) + 
  theme_bw()  
```

## ... shifting bars by group

```{r}
#| output-location: slide


# trying to improve readability 
autism_pids %>% 
  ggplot(mapping = aes(x = age_inputed, fill = gender )) + 
  # bars next to each other with `position = 'dodge'`
  geom_histogram(bins=40, position = 'dodge') + 
  theme_bw()
```

## ...facet by gender

That's still not very easy to digest. Instead of only filling, you can separate the data into multiple plots to improve readability

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes(x = age_inputed, fill = gender )) + 
  geom_histogram(color="#e9ecef", alpha=0.8, position = 'dodge') + 
  theme_bw() + 
  # splitting the gender groups, specifying `ncol` to see one above the other
  facet_wrap(~gender, ncol = 1)  + 
  scale_fill_cyclical(values = c("#9b2339","#005ca1"))
```

## ... adding 2 mean vert lines (by gender)

I want to see the mean vertical line for each of the subgroups, but now, I need to create a small dataframae of summary statistics.

I do so by using `dplyr` add a column `mean_age` with the group mean

```{r}
#| output-location: fragment
group_stats <- autism_pids %>% 
  dplyr::group_by(gender) %>% 
  dplyr::summarize(mean_age = mean(age_inputed),
                   median_age = median (age_inputed)) 

group_stats
```

## ...(Introducing tidyr::pivot_longer)

This is a case in which I need to reshape this small dataframe into `long` form. I do so using `tidyr::pivot_longer` function

My next plot will have two `data` sources

```{r}
#| output-location: fragment

group_stats_long <- group_stats %>% 
  tidyr::pivot_longer(cols = mean_age:median_age, 
                      names_to = "Stat", 
                      values_to = "Value") %>% 
  dplyr::mutate(label = as.character(glue::glue("{gender}_{Stat}")))

group_stats_long 
```

## ...facet by gender + 2 mean vert lines + `scales`

```{r}
#| output-location: slide

hist_plot <- autism_pids %>% 
  ggplot(aes(x = age_inputed, fill = gender)) + 
  geom_histogram(bins=30,color="#e9ecef", alpha=0.8, position = 'dodge') + 
  facet_wrap(~gender, ncol = 1 ) + 
  scale_fill_manual(values = c("#9b2339","#005ca1"))  +
  # adding vline 
  geom_vline(data = group_stats_long, 
             mapping = aes(xintercept = Value, color = Stat),
             lwd=1.5,
             linetype=6,
  ) + 
  labs(x = "age brackets", y = "n of individuals",
       color = "Stats",
       title = "Distribution of observations by gender",
       subtitle = "",
       caption = "Autism study") +
  theme_bw() + 
  theme(legend.position = "right",
        plot.title = element_text(face = "bold")) + 
  # increase number of x axis ticks 
  scale_color_manual(values = c( "#e68000", "#d8cf71")) +
  scale_x_continuous(breaks = seq(10, 100,10 ), limits = c(16, 86))

hist_plot
```

## Density `ggridges` package

As an alternative, you can use the {ggridges} package to make ridge plots. The geom `geom_density_ridges` calculates density estimates from the provided data and then plots those, using the ridgeline visualization. In this case I have added the median line.

```{r}
#| output-location: slide


# library(ggridges)
autism_pids %>% 
  # this takes also `y` = group
  ggplot(aes(x=age_inputed, y = gender, fill = gender)) +
  ggridges::geom_density_ridges() +
  # I can add quantile lines (2 is the median)
  stat_density_ridges(quantile_lines = TRUE, quantiles = c(0.5), alpha = 0.75)+  
  # increase number of x axis ticks 
  scale_x_continuous(breaks = seq(10, 100,10 ), limits = c(16, 86)) + 
  scale_fill_cyclical(values = c("#9b2339","#005ca1")) + 
  theme_bw() 
```

<!-- #theme(axis.text.x = element_text(angle = 90, size=8, vjust = 0.5, hjust=1)) -->

<!-- # https://talks.andrewheiss.com/2021-seacen/02_data-visualization/slides/02_grammar-of-graphics.html#67 -->

## Barchart

Bar charts provide a visual presentation of categorical data, with `geom_bar()` (height of the bar proportional to the number of cases in each group) 

```{r}
#| output-location: fragment

# Let's take a variable that we recoded as `factor`
class(autism_pids$ethnicity)
```

## Barchart (cont.)

```{r}
#### ...bare minimum ---------------------------------- 
autism_pids %>% 
  ggplot(aes(x = ethnicity )) + 
  geom_bar() +   
  theme_bw() 
```

## ...improve theme

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes(x = ethnicity )) + 
  geom_bar(fill = "steelblue") +
  # reference line  
  geom_hline(yintercept=100, color = "#9b2339", size=0.5, ) +
  labs(x = "ethnicity", y = "n of individuals",
       color = "Stats",
       title = "Distribution of observations by ethnicity",
       subtitle = "",
       caption = "Autism study")  +
  # --- wrap long x labels (flipped ) !!!
  #  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 10)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=50, vjust=0.75), 
        axis.text.y = element_text(size=10,face="bold"))  
```

## ...improve readability (reorder)

Reordering the bars by count using the package `forcats` and its function `fct_infreq` + (which we can do because ethnicity is coded as factor)

```{r}
#| output-location: slide

autism_pids %>% 
    # we modify our x like so 
    ggplot(aes(x = forcats::fct_infreq(ethnicity ))) + 
    geom_bar(fill = "steelblue") +
    geom_hline(yintercept=100, color = "#9b2339", size=0.5, ) +
    labs(x = "ethnicity", y = "n of individuals",
         color = "Stats",
         title = "Distribution of observations by ethnicity",
         subtitle = "",
         caption = "Autism study")  +
    # --- wrap long x labels (flipped ) !!!
    #  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 10)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle=50, vjust=0.75), 
          axis.text.y = element_text(size=10,face="bold"))  
```

## ...improve readability (highlight NA)

Let's highlight the fact that the last column is the number of missing values. 
```{r}
#| output-location: slide

# Highlight "NA" as separate category
autism_pids %>%
  ## --- prep the dataframe 
  # Add a factor variable with two levels to use as fill/highlight
  dplyr::mutate(highlight = forcats::fct_other(
    ethnicity, keep = "NA", other_level = "All Groups"))  %>% 
  ## --- ggplot 
  # we ADD to `aes mapping` also `fill = highlight`
  ggplot(aes(x = forcats::fct_infreq(ethnicity), fill = highlight)) + 
  geom_bar()+
  # Use custom color palettes
  scale_fill_manual(values=c("#0084e6")) +
  # Add a line at a significant level 
  geom_hline(yintercept=100, color = "#9b2339", size=0.5, ) +
  labs(x = "ethnicity", y = "n of individuals",
       color = "Stats",
       title = "Distribution of observations by ethnicity",
       subtitle = "",
       caption = "Autism study")  +
  # --- wrap long x labels (flipped ) !!!
  #  scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = 10)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=50, vjust=0.75), 
        axis.text.y = element_text(size=10,face="bold"))  +
  ## drop legend and Y-axis title
  theme(legend.position = "none") 
```

## Boxplot

As discussed in lecture 1, the boxplot is packed with information about a distribution.

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(aes(x = gender,  y= age_inputed, fill = gender)) +
  geom_boxplot(alpha=0.5)+
  theme_bw()   + 
  scale_fill_cyclical(values = c("#9b2339","#005ca1"))
```

<!-- # https://datavizf23.classes.andrewheiss.com/lesson/06-lesson.html -->

## Violin plot

Similarly, the violin plot is an interesting alternative, and it can be enriched by adding the `geom_point` geometry.

```{r}
#| output-location: slide

autism_pids %>% 
  ggplot(mapping = aes(y = age_inputed, x = gender, fill = gender)) +
  geom_violin(alpha=0.5) +
  geom_point(position = position_jitter(width = 0.1), size = 0.5)+ 
  scale_fill_cyclical(values = c("#9b2339","#005ca1")) +
  theme_bw()

```

# SAVING & EXPORTING OUTPUT ARTIFACTS

## Saving one plot

If I want to use these output files later, I can easily save in the output folder created at the beginning.

- save a plot with `ggplot2::ggsave`

```{r}
#| eval: false
#| 
ggsave (hist_plot, 
        filename = here::here("practice",  "data_output", "hist_plot.png"))
```

## Saving a `.Rds` data file.

- save a dataframe with `base::saveRDS`

```{r}
#| eval: false

saveRDS (object = autism_pids, 
         file =  here::here("practice",  "data_output", "autism_pids_v2.Rds"))
```

- (later) load a saved dataframe with `base::readRDS`

```{r}
#| eval: false

# to load it later I will use 
readRDS(here::here("practice",  "data_output", "autism_pids_v2.Rds")) 
```

::: aside
notice I renamed while saving: next time I load it it will be called "autism_pids_v2" <!-- autism_pids_v2 <- readRDS(here::here("practice",  "data_output", "autism_pids_v2.Rds")) -->
:::

<!-- # FOUNDATIONS OF INFERENCE -->

<!-- (lo lascerei x lab \# 2) -->
